#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

layout (binding = 1) uniform UniformBufferObject {
    mat4 viewInverse;
    mat4 projInverse;
    vec4 lightPos;
    vec4 objectColor;
    float time;
} ubo;

struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
    float padding;
};

layout (std140, binding = 2) readonly buffer SphereBuffer {
    Sphere spheres[];
} scene;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitRecord {
    float t;
    vec3 p;
    vec3 normal;
    vec3 color;
    bool hit;
};

HitRecord hitSphere(Ray r, Sphere s, float t_min, float t_max) {
    HitRecord rec;
    rec.hit = false;
    
    vec3 oc = r.origin - s.center;
    float a = dot(r.direction, r.direction);
    float b = dot(oc, r.direction);
    float c = dot(oc, oc) - s.radius * s.radius;
    float discriminant = b * b - a * c;
    
    if (discriminant > 0) {
        float temp = (-b - sqrt(discriminant)) / a;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.p = r.origin + r.direction * rec.t;
            rec.normal = (rec.p - s.center) / s.radius;
            rec.color = s.color;
            rec.hit = true;
            return rec;
        }
    }
    return rec;
}

vec3 trace(Ray r) {
    vec3 color = vec3(0.0);
    vec3 attenuation = vec3(1.0);
    
    // Simple Bounce Loop (Max 3 Bounce)
    for (int bounce = 0; bounce < 3; bounce++) {
        HitRecord closestHit;
        closestHit.hit = false;
        closestHit.t = 10000.0;
        
        // Check all spheres (Hardcoded loop size matching C++ upload)
        for(int i = 0; i < 3; i++) {
            HitRecord hit = hitSphere(r, scene.spheres[i], 0.001, closestHit.t);
            if(hit.hit) {
                closestHit = hit;
            }
        }
        
        if (closestHit.hit) {
            // Diffuse Lighting
            vec3 lightDir = normalize(vec3(ubo.lightPos) - closestHit.p);
            float diff = max(dot(closestHit.normal, lightDir), 0.0);
            
            // color += attenuation * closestHit.color * (diff * 0.8 + 0.2); // Ambient + Diffuse
            
            // Reflect
            vec3 target = closestHit.p + closestHit.normal + vec3(sin(ubo.time)*0.1, cos(ubo.time)*0.1, 0.5); // Simple Scatter
            // r.origin = closestHit.p;
            // r.direction = normalize(target - closestHit.p);
            // attenuation *= 0.5; // Darken each bounce
            
            // Simple Color Return
            color = closestHit.color * (diff * 0.8 + 0.2);
            return color; 
        } else {
            // Sky Color
            vec3 unit_direction = normalize(r.direction);
            float t = 0.5 * (unit_direction.y + 1.0);
            vec3 sky = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
            return attenuation * sky;
        }
    }
    return vec3(0.0);
}

void main() {
    ivec2 dim = imageSize(resultImage);
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
    
    if (coords.x >= dim.x || coords.y >= dim.y) return;

    vec2 uv = vec2(coords) / vec2(dim);
    uv = uv * 2.0 - 1.0; // -1 to 1

    vec4 target = ubo.projInverse * vec4(uv.x, uv.y, 1, 1);
    vec3 direction = vec3(ubo.viewInverse * vec4(normalize(vec3(target) / target.w), 0));
    vec3 origin = vec3(ubo.viewInverse * vec4(0, 0, 0, 1));

    Ray r;
    r.origin = origin;
    r.direction = normalize(direction);

    vec3 pixelColor = trace(r);

    imageStore(resultImage, coords, vec4(pixelColor, 1.0));
}
