#version 450
layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0) uniform sampler2D inputColor;
layout (binding = 1) buffer ExposureBuffer {
    float averageLuminance;
} exposure;

const float MIN_LOG_LUM = -8.0;
const float MAX_LOG_LUM = 3.0;
const float TIME_COEFF = 0.05; // Smoothing factor

// Helper: RGB to Luminance
float luminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

// NOTE: A proper auto-exposure requires a Histogram construction (Atomic Add) or
// Parallel Reduction (Downsampling).
// For this Phase 4 Implementation, we will do a simple Parallel Reduction approximation
// by reading a disparate set of pixels (Sampling) or just averaging the center for now to keep it simple 
// but functional without complex multi-pass reduction.
// 
// BETTER APPROACH: "Weighted Average" in one pass (Naive but works for test)

shared float groupLum[256]; // 16x16 threads

void main() {
    ivec2 dim = textureSize(inputColor, 0);
    ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    
    // Sample texture
    vec3 color = texelFetch(inputColor, uv, 0).rgb;
    float lum = luminance(color);
    
    // Log luminance
    float logLum = log(max(lum, 0.0001));
    
    // Local Reduction (This is a simplified example, ideally we loop)
    // For single-pass global average without reduction shader chain,
    // we can use atomicAdd on a global buffer but that is SLOW.
    // instead, let's just make one thread update the buffer gradually (Temporal Adaptation).
    // This shader basically runs parallel, but we only want to update ONCE per dispatch?
    // 
    // ACTUALLY: Let's do a "Center Metering" Logic
    // Only center thread runs the update logic? No, that samples 1 pixel.
    
    // REAL IMPLEMENTATION (Simplest Robust): 
    // 1. Thread 0,0 samples 100 random points and averages them.
    
    if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
        float totalLogLum = 0.0;
        int samples = 0;
        
        // Sample a grid
        for (int y = 0; y < dim.y; y += 20) {
            for (int x = 0; x < dim.x; x += 20) {
                vec3 c = texelFetch(inputColor, ivec2(x, y), 0).rgb;
                totalLogLum += log(max(luminance(c), 0.0001));
                samples++;
            }
        }
        
        float currentAvg = exp(totalLogLum / float(samples));
        
        // Temporal Blend
        float prevAvg = exposure.averageLuminance;
        exposure.averageLuminance = prevAvg + (currentAvg - prevAvg) * TIME_COEFF;
    }
}
